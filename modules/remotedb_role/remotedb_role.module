<?php

/**
 * @file
 * Assign and unassign roles based on subscriptions in remote database.
 */

use Drupal\remotedb\Entity\RemotedbInterface;
use Drupal\remotedb_role\Plugin\Action\AssignRoles;

// ---------------------------------------------------------------------------
// DRUPAL HOOKS
// ---------------------------------------------------------------------------

/**
 * Implements hook_help().
 */
function remotedb_role_help($path, $arg) {
  switch ($path) {
    case 'admin/config/services/remotedb/roles':
      $output = '<p>' . t("On this page you can configure which roles an user should be assigned when they own a certain subscription. <strong>Warning</strong>: when an user doesn't own one of the specified subscriptions for a certain role, this role will be automatically revoked for that user.") . '</p>';
      $output .= '<p>' . t('The roles are assigned/unassigned upon user login.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_user_login().
 *
 * Assigns/Unassigns roles for account.
 *
 * @FIXME
 * The $edit parameter is gone in Drupal 8. It has been left here in order to
 * prevent 'undefined variable' errors, but it will never actually be passed to
 * this hook. You'll need to modify this function and remove every reference to it.
 */

function remotedb_role_user_login(\Drupal\user\UserInterface $account, $edit = []) {
  list($assigned, $unassigned) = remotedb_role_assign_roles($account);
  if (remotedb_role_variable_get('debug')) {
    drupal_set_message(t('Assigned: @assigned', ['@assigned' => implode(', ', $assigned)]), 'status', FALSE);
    drupal_set_message(t('Unassigned: @unassigned', ['@unassigned' => implode(', ', $unassigned)]), 'status', FALSE);
  }
}

// ---------------------------------------------------------------------------
// UTIL
// ---------------------------------------------------------------------------

/**
 * Assign/unassign roles based on the subscriptions the user has.
 *
 * @param object $account
 *   The user account to assign/unassign roles for.
 *
 * @return array
 *   An array containing the roles that were assigned/unassigned:
 *   - assigned: (array) roles that were assigned.
 *   - unassigned: (array) roles that were unassigned.
 */
function remotedb_role_assign_roles(\Drupal\user\UserInterface $account) {
  if (!$account->hasPermission('remotedb_role.bypass')) {
    $remotedb = remotedb_role_get_remotedb();
    if ($remotedb instanceof RemotedbInterface) {
      $subscription_service_class = remotedb_role_variable_get('subscription_service');
      $subscription_service = new $subscription_service_class($remotedb);
      $action = new AssignRoles([], $subscription_service);
      return $action->execute($account);
    }
  }
  return [
    [],
    [],
  ];
}

/**
 * Gets remote database to use for user related actions.
 *
 * @return \Drupal\remotedb\Entity\RemotedbInterface | NULL
 *   An instance of RemotedbInterface, if found.
 *   NULL otherwise.
 */
function remotedb_role_get_remotedb() {
  $remotedb_id = remotedb_role_variable_get('remotedb');
  if ($remotedb_id) {
    $remotedb = entity_load_single('remotedb', $remotedb_id);
    if ($remotedb instanceof RemotedbInterface) {
      return $remotedb;
    }
  }
  return NULL;
}

/**
 * Get a remotedbuser setting.
 *
 * @param string $name
 *   The setting to get.
 *
 * @return mixed
 *   The value of the setting.
 */
function remotedb_role_variable_get($name) {
  // @FIXME
// // @FIXME
// // The correct configuration object could not be determined. You'll need to
// // rewrite this call manually.
// $value = variable_get('remotedb_role_' . $name, NULL);

  if (is_null($value)) {
    switch ($name) {
      case 'remotedb':
        $options = entity_get_controller('remotedb')->options();
        if (empty($options)) {
          return NULL;
        }
        reset($options);
        return key($options);

      case 'debug':
        return FALSE;

      case 'subscription_service':
        return 'Drupal\remotedb_role\SubscriptionService';
    }
  }
  return $value;
}
